
#### 부호 없는 정수 (Unsigned Integer, 0과 자연수)
- 컴퓨터에서 프로그래밍을 할 때에는 프로그래밍 언어에서 제공해주는 다양한 자료형(Data types)에 따라 다양한 비트 수를 사용할 수 있게 된다. 부호 없는 정수의 경우, 그 자료형에 해당하는 비트 수에 순차적으로 값을 넣어 해당 값을 표현한다.
- C언어의 경우, int형 변수는 4바이트(32비트)를 사용하기 때문에, 그에 따라 표현할 수 있는 최대 숫자 크기에 제한을 받는다. 이 크기 범위를 밑돌거나 넘어갈 경우, 오버플로우(언더플로우)가 일어난다.

- C 언어를 이용한 오버플로우 예제

```C
#include <stdio.h>

int main() {
	unsigned char c;

	c = 255;
	c = c + 1; // 오버플로우

	printf("%d\n", c);

	c = 0;
	c = c - 1; // 언더플로우

	printf("%d\n", c);

	return 0;
}
```

---

#### 부호 있는 정수 (Signed Integer)
- 부호가 있는 정수는 음의 값도 표현할 수 있어야 한다. 이를 구현하기 위해 부호와 절대값 표현을 사용하는 방식과, 보수 표현을 사용하는 방식의 두 가지 방식을 생각할 수 있다.

1. 부호와 절대값(Sign and Magnitude)
	- 부호를 표현하기 위해 생각할 수 있는 가장 쉬운 방법은 부호와 절대값이다. 이 방식은 MSB(Most Significant Bit, 가장 왼쪽 비트)가 0이면 '0 또는 양의 정수'를, MSB가 1이면 '0 또는 음의 정수'를 나타내는 방식이다.
		- +5 : 0000 0101<sub>2</sub>
		- -5 : 1000 0101<sub>2</sub>
	- 8비트로 이 방식을 사용하면, MSB를 부호 할당에 쓰고 나머지 7비트로 수를 표현해서 -127~+127까지 표현 가능하다. 단, 덧셈의 경우, 단순히 더할 경우 (+5) + (-5) = 0000 0101<sub>2</sub> + 1000 0101<sub>2</sub> = 1000 1010<sub>2</sub> = -10 (?) 와 같이 문제가 생기므로 다음과 같은 매커니즘으로 더해야 한다.
	
		1. 두 수의 부호를 비교한다.
		2. 부호가 동일하면 절대값을 서로 더한 후, 동일한 부호를 붙인다.
		3. 부호가 다르면 절대값이 큰 값에서 절대값이 작은 값을 뺀 후, 큰 절대값의 부호를 붙인다.

	- 이 방식으로 계산을 할 시 연산이 매우 느려지므로, 실제 컴퓨터에서는 잘 사용하지 않고 아래의 보수 표현을 주로 사용한다.

2. 2의 보수표현 (2's Complement binary representation)
	- 어떤 수 x에 대해, 그 수에 더했을 때 (타입값 범위 안에서) 합이 0이 되는 수 y를 x의 보수(complement)라 하며, 이를 이용하면 음의 정수를 나타낼 수 있다. 예를 들어, +10<sub>10</sub> = 0000 1010<sub>2</sub>의 보수는 1111 0110<sub>2</sub> 가 되며, 후자를 -10<sub>10</sub>으로 정의할 수 있다.
	- 이 정의를 이용하면 뺄셈도 잘 정의되는데, 예를 들면  0<sub>10</sub> - (+10<sub>10</sub>) = (1) 0000 0000<sub>2</sub> - 0000 0110<sub>2</sub> = 1111 0110<sub>2</sub> = -10<sub>10</sub>과 같이 문제 없이 계산되는 걸 알 수 있다. 그 외에도, 부호 표기법과는 다르게 양수/음수 여부를 따지지 않고 일반적인 비트 연산으로 덧셈을 처리할 수 있는 점도 장점이다.
	- 정의에 의해, 어떤 수 x의 보수를 구하는 방법은  x에 NOT 비트 연산을 취한 후 1을 더해주면 된다. 이 덕분에, 하드웨어를 이용해 매우 쉽고 빠르게 구할 수 있다는 장점이 있다.
	- 부호 표기법과의 차이점은, 부호 표기법과 다르게 보수 표현법은 숫자 0을 나타내는 방법이 유일하다는 점, 보수 표현법에서도 MSB는 부호 여부를 나타내기는 하지만 그 내용물은 부호 표기법과는 상이하다는 점 등이다.
	- 단, 보수 표기법에서도 오버플로우가 발생할 수 있다는 점은 유의해야 한다.

---

#### C 언어를 이용한 보수표현 예제

```C
#include <stdio.h>

int main() {
	int value = -1;

	printf("Decimal : %d \n", value); // 10진수
	printf("Octal : %o \n", value); // 8진수
	printf("Hexadecimal : %X \n", value); // 16진수

	return 0;
}
```

---

#### C 언어를 이용한 오버플로우 예제

```C
#include <stdio.h>

int main() {
	char c;

	c = 127;
	c = c + 1; // 오버플로우

	printf("%d\n", c);

	c = -128;
	c = c - 1; // 언더플로우

	printf("%d\n", c);

	return 0;
}
```

---

#### 연습 문제
- 0000 1101<sub>2</sub> = +13<sub>10</sub>
- 1000 1000<sub>2</sub> = -(0111 1000<sub>2</sub>) = -120<sub>10</sub>
- 1111 0011<sub>2</sub> = -(0000 1101<sub>2</sub>) = -13<sub>10</sub>
- 1100 1001<sub>2</sub> = -(0011 0111<sub>2</sub>) = -55<sub>10</sub>

---
